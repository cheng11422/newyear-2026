<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>2026 新年粒子烟花</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Microsoft YaHei', sans-serif;
        }
        canvas {
            display: block;
        }
        /* 加载提示 */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            opacity: 0.8;
            z-index: 100;
        }
        /* 性能提示 */
        .performance-hint {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            font-family: monospace;
            z-index: 50;
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>
<div class="loading" id="loading">加载中...</div>
<div class="performance-hint" id="performanceHint"></div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const loading = document.getElementById('loading');
    const performanceHint = document.getElementById('performanceHint');
    
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;
    
    // 性能优化配置
    const MAX_FIREWORKS = 10;
    const MAX_TOTAL_PARTICLES = 1800;
    const PARTICLE_OPTIMIZATION = window.devicePixelRatio > 1 ? 0.85 : 1;
    
    // 配置
    const particleSize = 3;
    const particleGap = 6;
    
    let particles = [];
    let fireworks = [];
    let frameCount = 0;
    let fps = 60;
    let lastTime = Date.now();
    
    // 精简后的新年祝福语序列
    const textSequence = [
        // 倒计时和新年到来
        { text: "再见 2025", time: 2500 },
        { text: "3", time: 800 },
        { text: "2", time: 800 },
        { text: "1", time: 800 },
        { text: "2026", time: 3000 },
        
        // 核心祝福
        { text: "新年快乐", time: 4000 },
        { text: "万事如意", time: 3500 },
        { text: "身体健康", time: 3500 },
        { text: "心想事成", time: 3500 },
        
        // 温馨祝福
        { text: "阖家幸福", time: 3500 },
        { text: "财源广进", time: 3500 },
        { text: "平安喜乐", time: 3500 },
        
        // 特别祝福
        { text: "岁岁平安", time: 3500 },
        { text: "马年大吉", time: 3500 },
        
        // 长句祝福
        { text: "愿新年胜旧年", time: 4000 },
        { text: "愿所愿皆如愿", time: 4000 },
        
        // 回到开始
        { text: "2026", time: 3000 }
    ];
    
    // 总时长约 60 秒
    
    let currentStep = 0;
    let lastStepTime = Date.now();
    let isInitialized = false;

    // 调整窗口大小
    window.addEventListener('resize', () => {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        if (isInitialized) {
            updateParticles(textSequence[currentStep].text);
        }
    });

    // --- 粒子系统（文字）---
    
    class Particle {
        constructor(x, y) {
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            this.targetX = x;
            this.targetY = y;
            this.vx = Math.random() * 2 - 1;
            this.vy = Math.random() * 2 - 1;
            this.color = `hsl(0, 0%, ${Math.random() * 30 + 70}%)`;
            this.size = particleSize;
            this.friction = 0.88 + Math.random() * 0.1;
        }
        
        update() {
            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            
            this.x += dx * 0.08;
            this.y += dy * 0.08;
            
            this.vx *= this.friction;
            this.vy *= this.friction;
            this.x += this.vx;
            this.y += this.vy;
            
            if (this.x < 0 || this.x > width) this.vx *= -0.8;
            if (this.y < 0 || this.y > height) this.vy *= -0.8;
        }
        
        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // --- 尺寸增大版细型带尾烟花系统（仅增大尺寸）---
    
    class FireworkParticle {
        constructor(x, y, color, isLarge = false) {
            this.x = x;
            this.y = y;
            this.angle = Math.random() * Math.PI * 2;
            
            // 保持原有的速度特性
            this.speed = isLarge ? 
                (Math.random() * 3.5 + 2.5) :  
                (Math.random() * 2.5 + 1.5);
            
            // 保持原有的物理特性
            this.friction = 0.91 + Math.random() * 0.04;
            this.gravity = 0.025 + Math.random() * 0.02;
            this.alpha = 1;
            this.color = color;
            this.vx = Math.cos(this.angle) * this.speed;
            this.vy = Math.sin(this.angle) * this.speed;
            
            // 仅增大尺寸（增加约40%）
            this.size = isLarge ? 
                (Math.random() * 2.2 + 2.0) :  // 原1.5-3.3 → 现在2.0-4.2
                (Math.random() * 1.3 + 0.9);    // 原0.7-1.7 → 现在0.9-2.2
            
            this.trail = [];
            this.maxTrailLength = isLarge ? 7 : 5;
            this.isLarge = isLarge;
            this.shouldDrawTrail = Math.random() > 0.25;
        }

        update() {
            if (this.shouldDrawTrail) {
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
            }
            
            this.vx *= this.friction;
            this.vy *= this.friction;
            this.vy += this.gravity;
            this.x += this.vx;
            this.y += this.vy;
            this.alpha -= this.isLarge ? 0.009 : 0.012;
            this.size *= 0.99;
            
            return this.alpha > 0.05;
        }

        draw() {
            if (this.shouldDrawTrail && this.trail.length > 0) {
                for (let i = 0; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    const trailAlpha = (i / this.trail.length) * this.alpha * 0.6;
                    
                    ctx.globalAlpha = trailAlpha;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, this.size * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            
            if (this.isLarge && this.alpha > 0.3) {
                ctx.globalAlpha = this.alpha * 0.3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 1.3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.globalAlpha = 1;
        }
    }

    class Firework {
        constructor() {
            this.x = Math.random() * width;
            this.y = height + 20;
            this.targetY = Math.random() * (height / 2.2) + 100;
            this.speed = Math.random() * 4 + 5;
            
            const hue = Math.floor(Math.random() * 360);
            const saturation = 75 + Math.random() * 20;
            const lightness = 55 + Math.random() * 30;
            this.color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            this.secondaryColor = `hsl(${(hue + 45) % 360}, ${saturation}%, ${lightness + 15}%)`;
            
            this.exploded = false;
            this.particles = [];
            this.trail = [];
            
            // 仅增大烟花头尺寸（增加约30%）
            this.size = 2.8; // 原2.2 → 现在2.8
            
            this.sparkCount = Math.floor((Math.random() * 60 + 70) * PARTICLE_OPTIMIZATION);
            this.largeSparkRatio = 0.3;
        }

        update() {
            if (!this.exploded) {
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > 6) this.trail.shift();
                
                this.y -= this.speed;
                if (this.y <= this.targetY) {
                    this.explode();
                    return true;
                }
            } else {
                let aliveCount = 0;
                for (let i = 0; i < this.particles.length; i++) {
                    if (this.particles[i].update()) {
                        aliveCount++;
                    }
                }
                
                if (aliveCount < this.particles.length) {
                    const newParticles = [];
                    for (let i = 0; i < this.particles.length; i++) {
                        if (this.particles[i].alpha > 0.05) {
                            newParticles.push(this.particles[i]);
                        }
                    }
                    this.particles = newParticles;
                }
                
                if (this.particles.length === 0) {
                    return false;
                }
            }
            return true;
        }

        explode() {
            this.exploded = true;
            
            const currentTotalParticles = getTotalParticleCount();
            if (currentTotalParticles > MAX_TOTAL_PARTICLES * 0.8) {
                this.sparkCount = Math.floor(this.sparkCount * 0.7);
            }
            
            const largeCount = Math.floor(this.sparkCount * this.largeSparkRatio);
            const smallCount = this.sparkCount - largeCount;
            
            for (let i = 0; i < largeCount; i++) {
                this.particles.push(new FireworkParticle(this.x, this.y, this.color, true));
            }
            
            for (let i = 0; i < smallCount; i++) {
                this.particles.push(new FireworkParticle(this.x, this.y, this.color, false));
            }
            
            const secondaryCount = Math.floor(this.sparkCount * 0.3);
            for (let i = 0; i < secondaryCount; i++) {
                const isLarge = Math.random() < 0.15;
                const particle = new FireworkParticle(
                    this.x + (Math.random() - 0.5) * 15,
                    this.y + (Math.random() - 0.5) * 15,
                    this.secondaryColor,
                    isLarge
                );
                particle.alpha = 0.7;
                this.particles.push(particle);
            }
            
            // 增大白色火花尺寸
            for (let i = 0; i < 4; i++) {
                const particle = new FireworkParticle(this.x, this.y, "white", true);
                particle.size = 3.2; // 原2.5 → 现在3.2
                particle.alpha = 0.8;
                particle.speed = Math.random() * 4 + 2.5;
                this.particles.push(particle);
            }
        }

        draw() {
            if (!this.exploded) {
                for (let i = 0; i < this.trail.length; i++) {
                    const alpha = i / this.trail.length * 0.5;
                    const size = this.size * (i/this.trail.length * 0.4 + 0.1);
                    
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.trail[i].x, this.trail[i].y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                
                // 增大发光效果
                ctx.shadowBlur = 12; // 原8 → 现在12
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            } else {
                for (let i = 0; i < this.particles.length; i++) {
                    this.particles[i].draw();
                }
            }
        }
        
        getParticleCount() {
            return this.particles.length;
        }
    }

    function getTotalParticleCount() {
        let count = 0;
        for (let i = 0; i < fireworks.length; i++) {
            count += fireworks[i].getParticleCount();
        }
        return count;
    }

    // --- 文字处理 ---
    
    function createTextParticles(text) {
        const offCanvas = document.createElement('canvas');
        const offCtx = offCanvas.getContext('2d');
        offCanvas.width = width;
        offCanvas.height = height;
        
        let fontSize = 150;
        if (text.length > 4) fontSize = 100;
        if (text.length > 6) fontSize = 80;
        if (window.innerWidth < 600) fontSize *= 0.6;

        offCtx.font = `bold ${fontSize}px "Microsoft YaHei", sans-serif`;
        offCtx.fillStyle = 'white';
        offCtx.textAlign = 'center';
        offCtx.textBaseline = 'middle';
        offCtx.fillText(text, width / 2, height / 2);
        
        const imageData = offCtx.getImageData(0, 0, width, height).data;
        const newTargets = [];
        
        const gap = window.innerWidth < 600 ? particleGap * 1.3 : particleGap;
        
        for (let y = 0; y < height; y += gap) {
            for (let x = 0; x < width; x += gap) {
                const index = (y * width + x) * 4;
                const alpha = imageData[index + 3];
                
                if (alpha > 128) {
                    newTargets.push({ x, y });
                }
            }
        }
        
        return newTargets;
    }

    function updateParticles(text) {
        const targets = createTextParticles(text);
        
        if (targets.length > particles.length) {
            const numToAdd = targets.length - particles.length;
            for (let i = 0; i < numToAdd; i++) {
                particles.push(new Particle(width / 2, height / 2));
            }
        }
        
        for (let i = 0; i < Math.min(particles.length, targets.length); i++) {
            particles[i].targetX = targets[i].x;
            particles[i].targetY = targets[i].y;
            particles[i].color = `hsl(0, 0%, ${Math.random() * 30 + 70}%)`;
        }
        
        if (targets.length < particles.length) {
            particles.splice(targets.length);
        }
    }

    // --- 主循环 ---
    
    function animate() {
        frameCount++;
        
        if (frameCount % 60 === 0) {
            const now = Date.now();
            fps = Math.round(1000 / ((now - lastTime) / 60));
            lastTime = now;
            
            const particleCount = getTotalParticleCount();
            performanceHint.textContent = `FPS: ${fps} | 烟花: ${fireworks.length} | 粒子: ${particleCount}`;
        }
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.fillRect(0, 0, width, height);
        
        const now = Date.now();
        const currentConfig = textSequence[currentStep];
        
        if (now - lastStepTime > currentConfig.time) {
            currentStep = (currentStep + 1) % textSequence.length;
            lastStepTime = now;
            updateParticles(textSequence[currentStep].text);
            
            if (fireworks.length < MAX_FIREWORKS) {
                const count = Math.min(4, MAX_FIREWORKS - fireworks.length);
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        if (fireworks.length < MAX_FIREWORKS) {
                            fireworks.push(new Firework());
                        }
                    }, i * 250);
                }
            }
        }

        for (let i = 0; i < particles.length; i++) {
            particles[i].update();
            particles[i].draw();
        }

        let spawnChance = 0.04;
        const particleCount = getTotalParticleCount();
        
        if (fps < 30) {
            spawnChance *= 0.6;
        } else if (fps > 50) {
            spawnChance *= 1.3;
        }
        
        if (particleCount > MAX_TOTAL_PARTICLES * 0.75 || fireworks.length >= MAX_FIREWORKS) {
            spawnChance *= 0.4;
        }
        
        if (textSequence[currentStep].text.includes("2026") || 
            textSequence[currentStep].text.includes("快乐")) {
            spawnChance *= 1.8;
        }
        
        if (Math.random() < spawnChance && fireworks.length < MAX_FIREWORKS) {
            fireworks.push(new Firework());
        }
        
        for (let i = fireworks.length - 1; i >= 0; i--) {
            const isAlive = fireworks[i].update();
            if (isAlive) {
                fireworks[i].draw();
            } else {
                fireworks.splice(i, 1);
            }
        }

        requestAnimationFrame(animate);
    }

    // --- 初始化 ---
    function init() {
        loading.style.display = 'none';
        updateParticles(textSequence[0].text);
        isInitialized = true;
        
        const initialCount = Math.min(5, MAX_FIREWORKS);
        for (let i = 0; i < initialCount; i++) {
            setTimeout(() => {
                fireworks.push(new Firework());
            }, i * 400);
        }
        
        animate();
    }

    window.addEventListener('load', () => {
        setTimeout(init, 500);
    });

</script>
</body>
</html>
