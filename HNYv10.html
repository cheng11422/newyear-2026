<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026 新年祝福</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Microsoft YaHei', sans-serif;
        }
        canvas {
            display: block;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            opacity: 0.8;
            z-index: 100;
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>
<div class="loading" id="loading">加载中...</div>

<script>
    console.log("开始加载...");
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const loading = document.getElementById('loading');
    
    // 设置画布大小
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    let width = canvas.width;
    let height = canvas.height;
    
    // 祝福语
    const texts = [
        "你终于开来看啦",
        "谢谢你的点入",
        "我喜欢你",
        "但我没这个勇气靠近你",
        "我也听过你想要的",
        "跟你不想要的",
        "我没有这个资格",
        "也给不了你想要的",
        "祝你找到幸福",
        "再见",
    ];
    
    let currentTextIndex = 0;
    let lastChangeTime = 0;
    let alpha = 0; // 淡入淡出透明度
    let fadeState = 'in'; // 'in' 淡入, 'hold' 保持, 'out' 淡出
    
    // 获取合适的字体大小
    function getFontSize(text) {
        const isMobile = width < 768;
        let baseSize = isMobile ? 28 : 40;
        
        // 根据文字长度调整
        if (text.length <= 4) return isMobile ? 35 : 50;
        if (text.length <= 8) return isMobile ? 32 : 45;
        if (text.length <= 12) return isMobile ? 28 : 40;
        if (text.length <= 16) return isMobile ? 24 : 35;
        return isMobile ? 20 : 30;
    }
    
    // 绘制当前文字
    function drawCurrentText() {
        const text = texts[currentTextIndex];
        const fontSize = getFontSize(text);
        
        // 清除画布
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, width, height);
        
        // 设置文字样式
        ctx.font = `bold ${fontSize}px Microsoft YaHei`;
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // 绘制文字
        ctx.fillText(text, width / 2, height / 2);
        
        // 添加发光效果
        if (alpha > 0.5) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
            ctx.lineWidth = 2;
            ctx.strokeText(text, width / 2, height / 2);
            ctx.shadowBlur = 0;
        }
        
        console.log(`显示: "${text}", 字体: ${fontSize}px, 透明度: ${alpha.toFixed(2)}`);
    }
    
    // 简单的烟花效果
    let fireworks = [];
    
    class Firework {
        constructor() {
            this.x = Math.random() * width;
            this.y = height + 20;
            this.speed = 3 + Math.random() * 3;
            this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
            this.size = 2 + Math.random() * 2;
            this.exploded = false;
            this.sparks = [];
        }
        
        update() {
            if (!this.exploded) {
                this.y -= this.speed;
                
                // 绘制上升轨迹
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y + 10, 1, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                
                if (this.y < height * 0.4) {
                    this.explode();
                }
            } else {
                // 更新火花
                for (let i = this.sparks.length - 1; i >= 0; i--) {
                    const spark = this.sparks[i];
                    spark.x += spark.vx;
                    spark.y += spark.vy;
                    spark.vy += 0.05; // 重力
                    spark.alpha -= 0.02;
                    spark.size *= 0.97;
                    
                    if (spark.alpha <= 0) {
                        this.sparks.splice(i, 1);
                    }
                }
            }
        }
        
        explode() {
            this.exploded = true;
            const sparkCount = 15 + Math.floor(Math.random() * 10);
            
            for (let i = 0; i < sparkCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                this.sparks.push({
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    alpha: 1,
                    color: this.color,
                    size: 1 + Math.random() * 2
                });
            }
        }
        
        draw() {
            if (!this.exploded) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            } else {
                this.sparks.forEach(spark => {
                    ctx.globalAlpha = spark.alpha;
                    ctx.fillStyle = spark.color;
                    ctx.beginPath();
                    ctx.arc(spark.x, spark.y, spark.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                });
            }
        }
    }
    
    // 主动画循环
    function animate(timestamp) {
        // 淡入淡出控制
        const fadeSpeed = 0.02;
        
        if (fadeState === 'in') {
            alpha += fadeSpeed;
            if (alpha >= 1) {
                alpha = 1;
                fadeState = 'hold';
            }
        } else if (fadeState === 'hold') {
            // 保持3秒
            if (timestamp - lastChangeTime > 3000) {
                fadeState = 'out';
            }
        } else if (fadeState === 'out') {
            alpha -= fadeSpeed;
            if (alpha <= 0) {
                alpha = 0;
                // 切换到下一句话
                currentTextIndex = (currentTextIndex + 1) % texts.length;
                lastChangeTime = timestamp;
                fadeState = 'in';
                
                // 偶尔添加烟花
                if (Math.random() < 0.4) {
                    fireworks.push(new Firework());
                }
            }
        }
        
        // 绘制文字
        drawCurrentText();
        
        // 更新和绘制烟花
        for (let i = fireworks.length - 1; i >= 0; i--) {
            const fw = fireworks[i];
            fw.update();
            fw.draw();
            
            // 移除完成的烟花
            if (fw.exploded && fw.sparks.length === 0) {
                fireworks.splice(i, 1);
            }
        }
        
        // 偶尔随机添加烟花
        if (Math.random() < 0.01) {
            fireworks.push(new Firework());
        }
        
        requestAnimationFrame(animate);
    }
    
    // 窗口大小调整
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        width = canvas.width;
        height = canvas.height;
    });
    
    // 初始化
    function init() {
        console.log("初始化...");
        loading.style.display = 'none';
        
        lastChangeTime = performance.now();
        alpha = 0;
        fadeState = 'in';
        
        // 开始动画
        requestAnimationFrame(animate);
        
        // 添加初始烟花
        setTimeout(() => {
            fireworks.push(new Firework());
        }, 1000);
    }
    
    // 确保页面加载完成
    window.addEventListener('load', init);
    
</script>
</body>
</html>
